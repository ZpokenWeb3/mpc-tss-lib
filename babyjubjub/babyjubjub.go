package babyjubjub

import (
	"crypto/elliptic"
	"fmt"
	"math/big"

	// elliptic "github.com/decred/dcrd/dcrec/secp256k1/v4"
	iden3bjj "github.com/iden3/go-iden3-crypto/babyjub"
)

// CurveParams contains the parameters for the Baby JubJub curve.
type CurveParams struct {
	// P is the prime used in the Baby JubJub field.
	P *big.Int

	// N is the order of the Baby JubJub curve group generated by the base point.
	N *big.Int

	// SubOrder is the order of the subgroup of the babyjub curve that contains the
	// points that we use.
	SubOrder *big.Int

	// Gx and Gy are the x and y coordinate of the base point, respectively.
	Gx, Gy *big.Int

	// A is one of the babyjub constants.
	A *big.Int

	// D is one of the babyjub constants.
	D *big.Int

	// BitSize is the size of the underlying Baby JubJub field in bits.
	BitSize int

	// H is the cofactor of the Baby JubJub curve.
	H int

	// ByteSize is simply the bit size / 8 and is provided for convenience
	// since it is calculated repeatedly.
	ByteSize int
}

var BabyJubJubParams = &CurveParams{
	// P is the prime used in the field.
	P: NewIntFromString("21888242871839275222246405745257275088548364400416034343698204186575808495617"),
	// N is the order of the curve group generated by the base point.
	N: iden3bjj.Order,
	// N:        NewIntFromString("21888242871839275222246405745257275088614511777268538073601725287587578984328"),
	// SubOrder: NewIntFromString("2736030358979909402780800718157159386076813972158567259200215660948447373041"),
	// Gx is the x coordinate of the base point.
	Gx: iden3bjj.B8.X,
	// Gx: NewIntFromString("5299619240641551281634865583518297030282874472190772894086521144482721001553"),
	// Gy is the y coordinate of the base point.
	Gy: iden3bjj.B8.Y,
	// Gy: NewIntFromString("16950150798460657717958625567821834550301663161624707787222815936182638968203"),
	// A:  NewIntFromString("168700"),
	// D:  NewIntFromString/("168696"),
	// BitSize is the size of the underlying field in bits.
	BitSize: 254, // Matches the field size
	// H is the cofactor of the curve.
	H: 8,
	// ByteSize is simply the bit size / 8 and is provided for convenience since it is calculated repeatedly.
	ByteSize: 32,
}

// Params returns the Baby JubJub curve parameters for convenience.
func Params() *CurveParams {
	return BabyJubJubParams
}

// BabyJubJubCurve provides an implementation for Baby JubJub that fits the ECC Curve
// interface from crypto/elliptic.
type BabyJubJubCurve struct {
	*elliptic.CurveParams
}

// Params returns the parameters for the curve.
//
// This is part of the elliptic.Curve interface implementation.
func (curve *BabyJubJubCurve) Params() *elliptic.CurveParams {
	return curve.CurveParams
}

// BabyJubJub is the global instance of the Baby Jubjub curve.
var babyjubjub = &BabyJubJubCurve{
	CurveParams: &elliptic.CurveParams{
		P:       BabyJubJubParams.P,
		N:       BabyJubJubParams.N,
		Gx:      BabyJubJubParams.Gx,
		Gy:      BabyJubJubParams.Gy,
		B:       big.NewInt(0),
		BitSize: BabyJubJubParams.BitSize,
		Name:    "babyjubjub",
	},
}

// BabyJubJub returns a reference to the Baby Jubjub curve.
func BabyJubJub() *BabyJubJubCurve {
	return babyjubjub
}

func (curve *BabyJubJubCurve) Add(x1, y1, x2, y2 *big.Int) (x, y *big.Int) {
	a := &iden3bjj.Point{X: x1, Y: y1}
	b := &iden3bjj.Point{X: x2, Y: y2}
	// Convert to projective from affine.
	c := iden3bjj.NewPoint().Projective().Add(a.Projective(), b.Projective()).Affine()

	return c.X, c.Y
}

func (curve *BabyJubJubCurve) ScalarMult(x1, y1 *big.Int, k []byte) (x, y *big.Int) {
	// Convert the scalar to a big int.
	s := new(big.Int).SetBytes(k)
	// s1 := s.Mod(s, curve.Params().N)
	a := &iden3bjj.Point{X: x1, Y: y1}
	c := iden3bjj.NewPoint().Mul(s, a)
	return c.X, c.Y
}

func (curve *BabyJubJubCurve) ScalarBaseMult(k []byte) (x, y *big.Int) {
	return curve.ScalarMult(curve.Gx, curve.Gy, k)
}

// fromHex converts the passed hex string into a big integer pointer and will
// panic is there is an error.  This is only provided for the hard-coded
// constants so errors in the source code can bet detected. It will only (and
// must only) be called for initialization purposes.
func fromHex(s string) *big.Int {
	if s == "" {
		return big.NewInt(0)
	}
	r, ok := new(big.Int).SetString(s, 16)
	if !ok {
		panic("invalid hex in source file: " + s)
	}
	return r
}

// NewIntFromString creates a new big.Int from a decimal integer encoded as a
// string.  It will panic if the string is not a decimal integer.
func NewIntFromString(s string) *big.Int {
	v, ok := new(big.Int).SetString(s, 10) //nolint:gomnd
	if !ok {
		panic(fmt.Sprintf("Bad base 10 string %s", s))
	}
	return v
}
